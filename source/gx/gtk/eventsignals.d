/*
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
 * distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
module gx.gtk.eventsignals;

import std.traits :
    isCallable,
    Parameters,
    ParameterStorageClass,
    ParameterStorageClassTuple,
    ReturnType;
import std.typecons : Flag, No, Tuple;

import gobject.c.functions : g_value_get_boxed;
import gobject.c.types : GClosure, GValue;
import gobject.dclosure : DClosure, DGClosure;
import gobject.value : getVal, setVal;

import gtk.widget : Widget;

/**
 * Connect an event signal where the event argument is a boxed GDK event.
 *
 * `gid` currently unmarshals many `GdkEvent*` structs using `g_value_get_pointer`,
 * which triggers GLib criticals and can yield null/invalid event objects.
 *
 * This helper bypasses the autogenerated `connect*Event` marshallers and instead
 * fetches the event argument with `g_value_get_boxed`.
 */
ulong connectBoxedEventSignal(TEvent, T)(Widget widget, string signalName, T callback, Flag!"After" after = No.After)
if (isCallable!T
    && is(ReturnType!T == bool)
    && (Parameters!T.length < 1 || (ParameterStorageClassTuple!T[0] == ParameterStorageClass.none && is(Parameters!T[0] == TEvent)))
    && (Parameters!T.length < 2 || (ParameterStorageClassTuple!T[1] == ParameterStorageClass.none && is(Parameters!T[1] : Widget)))
    && Parameters!T.length < 3)
{
    extern(C) void _cmarshal(GClosure* _closure, GValue* _returnValue, uint _nParams, const(GValue)* _paramVals, void* _invocHint, void* _marshalData)
    {
        assert(_nParams == 2, "Unexpected number of signal parameters");

        auto _dClosure = cast(DGClosure!T*) _closure;
        Tuple!(Parameters!T) _paramTuple;

        static if (Parameters!T.length > 0) {
            auto eventPtr = cast(void*) g_value_get_boxed(&_paramVals[1]);
            // Event pointers should always be present for GDK event signals.
            // Avoid throwing across the C boundary if something is unexpectedly null.
            if (eventPtr is null) {
                setVal!(bool)(_returnValue, false);
                return;
            }
            // `gid` event wrappers (e.g. `EventButton`, `EventKey`) are classes.
            // They copy the boxed struct into their `cInstance`, so `No.Take` is safe.
            _paramTuple[0] = new TEvent(eventPtr, No.Take);
        }

        static if (Parameters!T.length > 1)
            _paramTuple[1] = getVal!(Parameters!T[1])(&_paramVals[0]);

        auto _retval = _dClosure.cb(_paramTuple[]);
        setVal!(bool)(_returnValue, _retval);
    }

    auto closure = new DClosure(callback, &_cmarshal);
    return widget.connectSignalClosure(signalName, closure, after);
}

public:

import gdk.event_button : EventButton;
import gdk.event : Event;
import gdk.event_key : EventKey;
import gdk.event_scroll : EventScroll;

ulong connectButtonPressEventBoxed(T)(Widget widget, T callback, Flag!"After" after = No.After)
{
    return connectBoxedEventSignal!(EventButton)(widget, "button-press-event", callback, after);
}

ulong connectButtonReleaseEventBoxed(T)(Widget widget, T callback, Flag!"After" after = No.After)
{
    return connectBoxedEventSignal!(EventButton)(widget, "button-release-event", callback, after);
}

ulong connectKeyPressEventBoxed(T)(Widget widget, T callback, Flag!"After" after = No.After)
{
    return connectBoxedEventSignal!(EventKey)(widget, "key-press-event", callback, after);
}

ulong connectKeyReleaseEventBoxed(T)(Widget widget, T callback, Flag!"After" after = No.After)
{
    return connectBoxedEventSignal!(EventKey)(widget, "key-release-event", callback, after);
}

ulong connectDeleteEventBoxed(T)(Widget widget, T callback, Flag!"After" after = No.After)
{
    return connectBoxedEventSignal!(Event)(widget, "delete-event", callback, after);
}

ulong connectScrollEventBoxed(T)(Widget widget, T callback, Flag!"After" after = No.After)
{
    return connectBoxedEventSignal!(EventScroll)(widget, "scroll-event", callback, after);
}
